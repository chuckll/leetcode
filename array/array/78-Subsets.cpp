#include<stdio.h>
#include<vector>
using namespace std;

//第二种解法让我很惊叹。它是发掘到了一个规律，集合中每添加一个元素，则子集数目增加一倍，且增加的子集为所有原始子集加上新的元素。举个例子：nums=[1,2,3] 
//1. 初始时集合为空，子集为[ [] ]。 
//2. 添加一个元素1,即集合为[1]时，子集为空集和空集+元素1，即[ [], [1] ]。 
//3. 添加下一个元素2，集合为[1,2]，子集除了包含上一步的所有集合还新增了对应集合+元素2的所有集合，即[ [], [1], [2], [1,2]]，其中[2]是空集+元素2，[1,2]是[1]+元素2。 
//4. 添加下一个元素3，集合为[1,2,3]，类似的得到子集为[ [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]，其中[3]是空集+元素3，[1,3]是[1]+元素3，[2,3]是[2]+元素3，[1,2,3]是[1,2]+元素3。 

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res(1,vector<int>());

		for(int i = 0; i < nums.size(); i++)
		{
			int n = res.size();
			for(int j = 0; j < n; j++)
			{
				res.push_back(res[j]);                //将当前的子集复制到末尾
				res.back().push_back(nums[i]);          //在复制的子集上加上新的元素
			}
		}

		return res;
    }
};